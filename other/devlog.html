<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blog Posts</title>
<link rel="stylesheet" href="../styles/style.css">
<style>
  /* --- New Header Container --- */
  .header-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      margin-bottom: 20px;
  }

  header {
      flex: 1;
      text-align: center;
      margin-bottom: 10px;
  }

  .header-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
  }

  /* Search bar styles */
  .search-container {
      width: 100%;
      margin-top: 15px;
      text-align: center;
  }

  #tag-search-input {
      width: 80%;
      max-width: 400px;
      padding: 10px;
      font-size: 1rem;
      background-color: #0d283c;
      color: #fff;
      border: 2px solid #01edf0;
      border-radius: 5px;
      box-shadow: 0 0 5px rgba(1, 237, 240, 0.5);
      transition: all 0.3s ease;
  }

  #tag-search-input:focus {
      outline: none;
      box-shadow: 0 0 10px #01edf0, inset 0 0 5px #01edf0;
  }

  /* Fixed Post Button */
  #post-button {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      background-color: transparent;
      border: 2px solid #01edf0;
      color: #01edf0;
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      text-shadow: 0 0 5px #01edf0;
      transition: all 0.3s ease;
      box-shadow: 0 0 5px rgba(1, 237, 240, 0.5);
      border-radius: 5px;
  }

  #post-button:hover {
      background-color: rgba(1, 237, 240, 0.2);
  }

  /* Redesigned Post Form */
  #new-post-section {
      background: #0d283c;
      border: 2px solid #01edf0;
      box-shadow: 0 0 15px #01edf0;
      padding: 30px;
      border-radius: 10px;
      max-width: 700px;
      width: 90%;
      margin: 20px auto;
      display: none; /* Initially hidden */
  }

  #new-post-section.visible {
      display: block; /* Shown when the button is clicked */
  }

  #new-post-section h2 {
      margin-top: 0;
  }

  .post-actions-form-group {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
  }
  
  /* --- PFP Styles --- */
  .pfp-small {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid #01edf0;
      margin-right: 10px;
  }

  .post-meta {
      display: flex;
      align-items: center;
      margin-top: 10px;
  }

  .comment-header {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
  }

  .comment-item p {
      margin: 0;
  }
  
  /* Other styles remain the same */
  .comments-section {
      text-align: left;
      margin-top: 15px;
      width: 100%;
      box-sizing: border-box;
      padding: 0 10px;
  }

  .comments-toggle {
      background-color: transparent;
      border: 1px solid #01edf0;
      color: #01edf0;
      padding: 8px 15px;
      font-size: 0.9rem;
      cursor: pointer;
      text-shadow: 0 0 5px #01edf0;
      transition: all 0.3s ease;
      box-shadow: 0 0 5px rgba(1, 237, 240, 0.5);
      margin-bottom: 10px;
  }

  .comments-toggle:hover {
      background-color: rgba(1, 237, 240, 0.2);
  }

  .comments-list {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-in-out;
  }

  .comments-list.show {
      /* This will be set by JavaScript dynamically */
  }

  .comment-item {
      background: rgba(13, 40, 60, 0.7);
      border-left: 2px solid #01edf0;
      padding: 8px 12px;
      margin-top: 8px;
      position: relative;
      padding-right: 50px;
  }

  .comment-item p {
      margin: 0 0 5px 0;
      font-size: 0.9rem;
  }

  .comment-item small {
      display: block;
      font-size: 0.7rem;
      color: rgba(1, 237, 240, 0.7);
  }

  .comment-form {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
  }

  .comment-input {
      flex: 1;
      min-height: 50px;
      resize: vertical;
      min-width: 0;
  }

  .submit-comment-btn, .edit-comment-btn, .delete-comment-btn, .delete-post-btn, .cancel-btn {
      background-color: transparent;
      border: 2px solid #01edf0;
      color: #01edf0;
      padding: 8px 15px;
      cursor: pointer;
      text-shadow: 0 0 5px #01edf0;
      transition: all 0.3s ease;
      box-shadow: 0 0 5px rgba(1, 237, 240, 0.5);
      border-radius: 0;
      font-size: 0.8rem;
      margin-left: 5px;
  }

  .submit-comment-btn:hover, .edit-comment-btn:hover, .delete-comment-btn:hover, .delete-post-btn:hover, .cancel-btn:hover {
      background-color: rgba(1, 237, 240, 0.2);
      box-shadow: 0 0 10px #01edf0;
  }

  /* Make delete buttons stand out more */
  .delete-comment-btn, .delete-post-btn {
      border-color: #ff3333;
      color: #ff3333;
      box-shadow: 0 0 5px rgba(255, 51, 51, 0.5);
  }
  .delete-comment-btn:hover, .delete-post-btn:hover {
      background-color: rgba(255, 51, 51, 0.2);
      box-shadow: 0 0 10px #ff3333;
  }

  .comment-actions {
    position: absolute;
    top: 5px;
    right: 5px;
    display: flex;
    gap: 5px;
  }

  .post-content {
      margin-bottom: 0;
      position: relative;
      padding-right: 120px;
  }

  /* Mobile-first adjustment */
  @media (max-width: 768px) {
    .post-content {
      padding-right: 10px;
    }
  }

  .post-actions {
      position: absolute;
      top: 15px;
      right: 15px;
  }

  .post-item .divider {
      margin-top: 20px;
  }

  .editing .comment-input {
      border: 2px solid #ffcc00;
      box-shadow: 0 0 10px #ffcc00, inset 0 0 5px #ffcc00;
  }

  /* --- Image Size Adjustments --- */
  .post-image-preview {
      max-width: 100%;
      height: auto;
      margin-top: 15px;
      border: 1px solid #01edf0;
      box-shadow: 0 0 10px rgba(1, 237, 240, 0.5);
      cursor: pointer;
      transition: transform 0.3s ease;
  }

  @media (min-width: 769px) {
      .post-image-preview {
          max-width: 50%;
      }
  }

  .post-image-preview:hover {
      transform: scale(1.02);
  }

  /* Full-screen overlay for the maximized image */
  .image-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
  }

  .image-container {
      position: relative;
      max-width: 90%;
      max-height: 90%;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      background: #0d283c;
      border: 2px solid #01edf0;
      box-shadow: 0 0 20px #01edf0;
  }

  .maximized-image {
      max-width: 100%;
      max-height: 100vh;
      object-fit: contain;
  }

  .close-btn {
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 30px;
      color: #01edf0;
      cursor: pointer;
      text-shadow: 0 0 10px #01edf0;
      transition: transform 0.2s ease;
  }

  .close-btn:hover {
      transform: scale(1.2);
  }

  #notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
  }

  .notification {
      background: rgba(13, 40, 60, 0.9);
      backdrop-filter: blur(5px);
      border: 1px solid;
      padding: 15px 20px;
      border-radius: 5px;
      box-shadow: 0 0 10px;
      color: #fff;
      opacity: 1;
      transition: opacity 0.5s ease-in-out;
      min-width: 250px;
  }

  .notification.success {
      border-color: #01edf0;
      box-shadow: 0 0 10px rgba(1, 237, 240, 0.7);
      text-shadow: 0 0 5px #01edf0;
  }

  .notification.error {
      border-color: #ff3333;
      box-shadow: 0 0 10px rgba(255, 51, 51, 0.7);
      text-shadow: 0 0 5px #ff3333;
  }

  /* Tag styles */
  .tags-container {
    margin-top: 5px;
  }
  .tag {
    display: inline-block;
    background-color: #01edf0;
    color: #0d283c;
    font-size: 0.7rem;
    padding: 2px 8px;
    border-radius: 12px;
    margin-right: 5px;
    text-shadow: none;
    cursor: pointer;
  }
  .tag:hover {
    filter: brightness(1.2);
  }

  /* Pagination styles */
  .pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 20px;
    gap: 10px;
  }
  .page-btn {
    background-color: transparent;
    border: 2px solid #01edf0;
    color: #01edf0;
    padding: 8px 15px;
    cursor: pointer;
    text-shadow: 0 0 5px #01edf0;
    transition: all 0.3s ease;
    box-shadow: 0 0 5px rgba(1, 237, 240, 0.5);
    border-radius: 0;
  }
  .page-btn:hover:not(:disabled) {
    background-color: rgba(1, 237, 240, 0.2);
  }
  .page-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  .page-info {
    font-size: 1rem;
    color: #fff;
  }
</style>
</head>
<body>
    <div class="header-container">
        <header>
            <h1>Dev Log</h1>
        </header>
        <div class="header-buttons">
            <a href="/index.html" class="btn back-btn">Back to Home</a>
        </div>
        <div class="search-container">
            <input type="text" id="tag-search-input" placeholder="Search posts by tag...">
        </div>
    </div>

    <div id="new-post-section" class="login-container new-post-form">
        <h2>Create a New Post</h2>
        <input type="text" id="post-title" placeholder="Post Title" class="input-field">
        <textarea id="post-content" placeholder="Post Content" class="input-field"></textarea>
        <input type="text" id="post-tags" placeholder="Tags (e.g., firebase, gamedev)" class="input-field">
        <label for="post-image" class="file-label btn">Choose Image</label>
        <input type="file" id="post-image" accept="image/*" class="file-input">
        <div class="post-actions-form-group">
            <button id="cancel-btn" class="btn cancel-btn">Cancel</button>
            <button id="create-post-btn" class="btn username-btn">Create Post</button>
        </div>
    </div>

    <div id="posts-container" class="posts-list-container"></div>

    <div class="pagination">
        <button id="prev-page-btn" class="page-btn">Previous</button>
        <span id="page-info" class="page-info">Page 1 of 1</span>
        <button id="next-page-btn" class="page-btn">Next</button>
    </div>

    <button id="post-button" class="btn username-btn">Post</button>

    <div id="notification-container"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getDatabase, ref, get, push, set, remove, onValue, update } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
        import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-storage.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyAUZZBN9qoM34lsvyEOeK2znSSw6kKMcEE",
            authDomain: "yikegames-website.firebaseapp.com",
            databaseURL: "https://yikegames-website-default-rtdb.firebaseio.com/",
            projectId: "yikegames-website",
            storageBucket: "yikegames-website.firebasestorage.app",
            messagingSenderId: "1086586566551",
            appId: "1:1086586566551:web:b64dfc25e6e6ac5a09b6d2",
            measurementId: "G-FXH0D07D86"
        };
      
        const CLOUDINARY_CLOUD_NAME = "dhptbygpt";
        const CLOUDINARY_UPLOAD_PRESET = "unsigned_upload";
      
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
      
        const postsContainer = document.getElementById("posts-container");
        const newPostSection = document.getElementById("new-post-section");
        const postTitleInput = document.getElementById("post-title");
        const postContentInput = document.getElementById("post-content");
        const postImageInput = document.getElementById("post-image");
        const postTagsInput = document.getElementById("post-tags");
        const createPostBtn = document.getElementById("create-post-btn");
        const prevBtn = document.getElementById("prev-page-btn");
        const nextBtn = document.getElementById("next-page-btn");
        const pageInfoSpan = document.getElementById("page-info");
        const postButton = document.getElementById("post-button");
        const tagSearchInput = document.getElementById("tag-search-input");
        const cancelButton = document.getElementById("cancel-btn");
      
        const postsPerPage = 5;
        let currentPage = 1;
        let currentUserIsDeveloper = false;
        let currentEditingComment = null;
        const postsRef = ref(db, "posts");
        const usersRef = ref(db, "users");
        let allPostsCache = [];
        let usersCache = {};
        let currentFilterTag = null;
      
        function showNotification(message, isSuccess = true) {
            const notificationContainer = document.getElementById("notification-container");
            const notification = document.createElement("div");
            notification.classList.add("notification");
            if (isSuccess) {
                notification.classList.add("success");
            } else {
                notification.classList.add("error");
            }
            notification.innerHTML = `<p>${message}</p>`;
      
            notificationContainer.appendChild(notification);
      
            setTimeout(() => {
                notification.style.opacity = "0";
                setTimeout(() => {
                    notification.remove();
                }, 500);
            }, 3000);
        }
      
        async function fetchUsers() {
            const snapshot = await get(usersRef);
            if (snapshot.exists()) {
                usersCache = snapshot.val();
            }
        }
      
        function fetchPosts(filterTag = null) {
            currentFilterTag = filterTag;
            onValue(postsRef, (snapshot) => {
                const postsData = snapshot.val();
                allPostsCache = [];
                if (postsData) {
                    allPostsCache = Object.entries(postsData).map(([key, value]) => ({
                        id: key,
                        ...value
                    }));
                    allPostsCache.sort((a, b) => b.timestamp - a.timestamp);
                }
      
                let filteredPosts = allPostsCache;
                if (currentFilterTag) {
                    filteredPosts = allPostsCache.filter(post => post.tags && post.tags.includes(currentFilterTag));
                }
      
                const totalPages = Math.ceil(filteredPosts.length / postsPerPage);
      
                prevBtn.disabled = currentPage === 1;
                nextBtn.disabled = currentPage >= totalPages;
                pageInfoSpan.textContent = `Page ${currentPage} of ${totalPages || 1}`;
      
                const startIndex = (currentPage - 1) * postsPerPage;
                const paginatedPosts = filteredPosts.slice(startIndex, startIndex + postsPerPage);
      
                renderPosts(paginatedPosts);
            });
        }
      
        function getPfpUrl(authorName) {
            const userKeys = Object.keys(usersCache);
            const user = userKeys.find(key => usersCache[key].displayName === authorName || usersCache[key].email === authorName);
            return user && usersCache[user].photoURL ? usersCache[user].photoURL : "https://res.cloudinary.com/dhptbygpt/image/upload/v1700000000/default-pfp.png";
        }
      
        function renderPosts(posts) {
            postsContainer.innerHTML = "";
            const user = auth.currentUser;
      
            if (posts.length > 0) {
                posts.forEach(post => {
                    const postElement = document.createElement("div");
                    postElement.classList.add("post-item");
      
                    const postAuthorPfp = getPfpUrl(post.author);
      
                    let commentsHtml = '';
                    if (post.comments) {
                        const sortedComments = Object.entries(post.comments).map(([key, value]) => ({
                            id: key,
                            ...value,
                        })).sort((a, b) => a.timestamp - b.timestamp);
                        commentsHtml = sortedComments.map(comment => {
                            const commentAuthorPfp = getPfpUrl(comment.author);
                            return `
                                <div class="comment-item" data-comment-id="${comment.id}">
                                    <div class="comment-header">
                                        <img src="${commentAuthorPfp}" alt="Profile Picture" class="pfp-small">
                                        <p>${comment.text}</p>
                                    </div>
                                    <small>By ${comment.author} on ${new Date(comment.timestamp).toLocaleString()}</small>
                                    <div class="comment-actions">
                                        ${(user && (user.email === comment.author || user.displayName === comment.author)) ? `<button class="edit-comment-btn" data-post-id="${post.id}" data-comment-id="${comment.id}">Edit</button>` : ''}
                                        ${(user && (user.email === comment.author || currentUserIsDeveloper)) ? `<button class="delete-comment-btn" data-post-id="${post.id}" data-comment-id="${comment.id}">Delete</button>` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('');
                    }
      
                    const tagsHtml = (post.tags || []).map(tag => `<span class="tag" data-tag="${tag}">${tag}</span>`).join('');
      
                    postElement.innerHTML = `
                        <div class="post-content">
                            <h3>${post.title}</h3>
                            <div class="post-actions">
                                ${currentUserIsDeveloper ? `<button class="delete-post-btn" data-post-id="${post.id}">Delete Post</button>` : ''}
                            </div>
                            <p>${post.content}</p>
                            ${post.imageUrl ? `<img src="${post.imageUrl}" alt="${post.title}" class="post-image-preview">` : ''}
                            <div class="tags-container">${tagsHtml}</div>
                            <div class="post-meta">
                                <img src="${postAuthorPfp}" alt="Profile Picture" class="pfp-small">
                                <small>By ${post.author} on ${new Date(post.timestamp).toLocaleString()}</small>
                            </div>
                        </div>
                        <div class="comments-section">
                            <button class="comments-toggle">Show/Hide Comments (${post.comments ? Object.keys(post.comments).length : 0})</button>
                            <div class="comments-list">
                                ${commentsHtml}
                                <div class="comment-form">
                                    <textarea class="input-field comment-input" placeholder="Add a comment..."></textarea>
                                    <button class="submit-comment-btn" data-post-id="${post.id}">Submit</button>
                                </div>
                            </div>
                        </div>
                        <div class="divider"></div>
                    `;
                    postsContainer.appendChild(postElement);
                });
            } else {
                postsContainer.innerHTML = '<p class="info-message">No posts yet. Be the first to create one!</p>';
            }
        }
      
        async function loadPosts() {
            await fetchUsers();
            const user = auth.currentUser;
            currentUserIsDeveloper = false;
            postButton.style.display = "none";
            newPostSection.classList.remove('visible');
      
            if (user) {
                const userRef = ref(db, 'users/' + user.uid);
                const snapshot = await get(userRef);
                if (snapshot.exists() && snapshot.val().isDeveloper) {
                    currentUserIsDeveloper = true;
                    postButton.style.display = "block";
                }
            }
      
            fetchPosts();
        }
      
        onAuthStateChanged(auth, async (user) => {
            loadPosts();
        });
      
        async function createPost() {
            const title = postTitleInput.value.trim();
            const content = postContentInput.value.trim();
            const imageFile = postImageInput.files[0];
            const tags = postTagsInput.value.split(',').map(tag => tag.trim().toLowerCase()).filter(tag => tag);
            const user = auth.currentUser;
      
            if (!user) {
                showNotification("You must be logged in to create a post.", false);
                return;
            }
      
            const userRef = ref(db, 'users/' + user.uid);
            const snapshot = await get(userRef);
            if (!snapshot.exists() || !snapshot.val().isDeveloper) {
                showNotification("You do not have permission to create posts.", false);
                return;
            }
      
            if (!title || !content) {
                showNotification("Please enter a title and content for your post.", false);
                return;
            }
      
            createPostBtn.disabled = true;
            createPostBtn.innerText = "Creating...";
      
            let imageUrl = null;
      
            try {
                if (imageFile) {
                    const formData = new FormData();
                    formData.append("file", imageFile);
                    formData.append("upload_preset", CLOUDINARY_UPLOAD_PRESET);
                    const response = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`, {
                        method: "POST",
                        body: formData,
                    });
                    const data = await response.json();
                    if (response.ok) {
                        imageUrl = data.secure_url;
                    } else {
                        console.error("Cloudinary upload failed:", data);
                        showNotification("Image upload failed. Please try again.", false);
                        return;
                    }
                }
      
                const newPostRef = push(ref(db, "posts"));
                await set(newPostRef, {
                    title,
                    content,
                    imageUrl,
                    tags,
                    author: user.displayName || user.email,
                    timestamp: Date.now()
                });
                showNotification("Post created successfully!");
            } catch (error) {
                console.error("Operation failed:", error);
                showNotification("An error occurred. Please try again.", false);
            } finally {
                createPostBtn.disabled = false;
                createPostBtn.innerText = "Create Post";
                postTitleInput.value = "";
                postContentInput.value = "";
                postImageInput.value = "";
                postTagsInput.value = "";
                togglePostForm(); // Hide the form after submission
            }
        }
      
        function togglePostForm() {
            newPostSection.classList.toggle('visible');
        }
      
        function hidePostForm() {
            newPostSection.classList.remove('visible');
        }
      
        postButton.addEventListener("click", togglePostForm);
        cancelButton.addEventListener("click", hidePostForm);
      
        createPostBtn.addEventListener("click", createPost);
      
        tagSearchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim().toLowerCase();
            currentPage = 1;
            if (query) {
                fetchPosts(query);
            } else {
                fetchPosts();
            }
        });
      
        postsContainer.addEventListener('click', async (e) => {
            const user = auth.currentUser;
      
            if (e.target.classList.contains('tag')) {
                const tag = e.target.dataset.tag;
                tagSearchInput.value = tag;
                currentPage = 1;
                fetchPosts(tag);
                return;
            }
      
            if (e.target.classList.contains('submit-comment-btn')) {
                if (!user) {
                    showNotification("You must be logged in to comment.", false);
                    return;
                }
      
                const postId = e.target.dataset.postId;
                const commentInput = e.target.parentElement.querySelector('.comment-input');
                const commentText = commentInput.value.trim();
      
                if (commentText) {
                    if (currentEditingComment && currentEditingComment.postId === postId) {
                        const commentRef = ref(db, `posts/${postId}/comments/${currentEditingComment.commentId}`);
                        await update(commentRef, {
                            text: commentText,
                        });
                        showNotification("Comment updated successfully!");
                        currentEditingComment = null;
                        e.target.innerText = "Submit";
                        commentInput.parentElement.classList.remove('editing');
                    } else {
                        const commentsRef = ref(db, `posts/${postId}/comments`);
                        const newCommentRef = push(commentsRef);
                        await set(newCommentRef, {
                            text: commentText,
                            author: user.displayName || user.email,
                            timestamp: Date.now()
                        });
                        showNotification("Comment created successfully!");
                    }
                    commentInput.value = "";
                }
            }
      
            if (e.target.classList.contains('edit-comment-btn')) {
                const postId = e.target.dataset.postId;
                const commentId = e.target.dataset.commentId;
                const commentItem = e.target.closest('.comment-item');
                const commentText = commentItem.querySelector('p').innerText;
                const postElement = e.target.closest('.post-item');
                const commentInput = postElement.querySelector('.comment-input');
                const submitBtn = postElement.querySelector('.submit-comment-btn');
      
                commentInput.value = commentText;
                submitBtn.innerText = "Update";
                commentInput.focus();
                commentInput.parentElement.classList.add('editing');
                currentEditingComment = { postId, commentId };
            }
      
            if (e.target.classList.contains('delete-comment-btn')) {
                if (!confirm("Are you sure you want to delete this comment?")) return;
                const postId = e.target.dataset.postId;
                const commentId = e.target.dataset.commentId;
                const commentRef = ref(db, `posts/${postId}/comments/${commentId}`);
                await remove(commentRef);
                showNotification("Comment deleted successfully!");
            }
      
            if (e.target.classList.contains('delete-post-btn')) {
                if (!currentUserIsDeveloper) {
                    showNotification("You do not have permission to delete posts.", false);
                    return;
                }
                if (!confirm("Are you sure you want to delete this post?")) return;
                const postId = e.target.dataset.postId;
                const postRef = ref(db, `posts/${postId}`);
                await remove(postRef);
                showNotification("Post deleted successfully!");
            }
      
            if (e.target.classList.contains('comments-toggle')) {
                const commentsList = e.target.nextElementSibling;
                commentsList.classList.toggle('show');
                if (commentsList.classList.contains('show')) {
                    commentsList.style.maxHeight = commentsList.scrollHeight + 'px';
                } else {
                    commentsList.style.maxHeight = '0';
                }
            }
      
            if (e.target.classList.contains('post-image-preview')) {
                const imageUrl = e.target.src;
                maximizeImage(imageUrl);
            }
        });
      
        prevBtn.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                fetchPosts(currentFilterTag);
            }
        });
      
        nextBtn.addEventListener('click', () => {
            currentPage++;
            fetchPosts(currentFilterTag);
        });
      
        function maximizeImage(imageSrc) {
            const overlay = document.createElement('div');
            overlay.classList.add('image-overlay');
            const imageContainer = document.createElement('div');
            imageContainer.classList.add('image-container');
            const maximizedImg = document.createElement('img');
            maximizedImg.src = imageSrc;
            maximizedImg.classList.add('maximized-image');
            const closeBtn = document.createElement('span');
            closeBtn.classList.add('close-btn');
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => {
                document.body.removeChild(overlay);
            };
            imageContainer.appendChild(maximizedImg);
            imageContainer.appendChild(closeBtn);
            overlay.appendChild(imageContainer);
            document.body.appendChild(overlay);
            overlay.onclick = (e) => {
                if (e.target.classList.contains('image-overlay')) {
                    document.body.removeChild(overlay);
                }
            };
        }
      
        document.body.classList.add('fade-enter');
        setTimeout(() => {
            document.body.classList.add('fade-enter-active');
        }, 10);
      
        document.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href && !href.startsWith('http')) {
                    e.preventDefault();
                    document.body.classList.remove('fade-enter-active');
                    document.body.classList.add('fade-exit-active');
                    setTimeout(() => {
                        window.location.href = href;
                    }, 500);
                }
            });
        });
    </script>
</body>
</html>
